<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®¹å™¨ç»ˆç«¯ - è€ç‹å‡ºå“</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/xterm/5.3.0/xterm.min.css" rel="stylesheet">
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }

        .terminal-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .terminal-header {
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 10px 20px;
            border-bottom: 2px solid #00ff00;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .terminal-title {
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff00;
        }

        .terminal-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-connected {
            background: #00ff00;
        }

        .status-disconnected {
            background: #ff0000;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .terminal-body {
            flex: 1;
            background: #000000;
            padding: 20px;
            overflow: hidden;
        }

        #terminal {
            height: 100%;
            width: 100%;
        }

        .terminal-controls {
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-top: 1px solid #00ff00;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn-terminal {
            background: transparent;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 5px 15px;
            border-radius: 3px;
            font-size: 12px;
            transition: all 0.3s;
        }

        .btn-terminal:hover {
            background: #00ff00;
            color: #000000;
            box-shadow: 0 0 10px #00ff00;
        }

        .terminal-info {
            color: #00ff00;
            font-size: 12px;
            margin-left: auto;
        }

        .help-text {
            color: #888;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="terminal-container">
        <!-- ç»ˆç«¯å¤´éƒ¨ -->
        <div class="terminal-header">
            <div class="terminal-title">
                <i class="fas fa-terminal"></i> å®¹å™¨ç»ˆç«¯ - è€ç‹çš„é»‘ç§‘æŠ€
            </div>
            <div class="terminal-status">
                <div id="statusIndicator" class="status-indicator status-disconnected"></div>
                <span id="statusText">è¿æ¥ä¸­...</span>
            </div>
        </div>

        <!-- ç»ˆç«¯ä¸»ä½“ -->
        <div class="terminal-body">
            <div id="terminal"></div>
        </div>

        <!-- ç»ˆç«¯æ§åˆ¶æ  -->
        <div class="terminal-controls">
            <button id="clearBtn" class="btn-terminal">
                <i class="fas fa-eraser"></i> æ¸…å±
            </button>
            <button id="resizeBtn" class="btn-terminal">
                <i class="fas fa-expand"></i> è°ƒæ•´å¤§å°
            </button>
            <button id="copyBtn" class="btn-terminal">
                <i class="fas fa-copy"></i> å¤åˆ¶
            </button>
            <button id="pasteBtn" class="btn-terminal">
                <i class="fas fa-paste"></i> ç²˜è´´
            </button>
            <div class="terminal-info">
                <span class="help-text">Ctrl+C: ä¸­æ–­ | Ctrl+D: é€€å‡º | Ctrl+L: æ¸…å±</span>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xterm/5.3.0/xterm.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xterm-addon-fit/0.8.0/xterm-addon-fit.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xterm-addon-web-links/0.9.0/xterm-addon-web-links.min.js"></script>
    <script>
        class WebTerminal {
            constructor() {
                this.term = null;
                this.socket = null;
                this.fitAddon = null;
                this.isConnecting = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;

                this.initTerminal();
                this.connect();
                this.bindEvents();
            }

            initTerminal() {
                // åˆå§‹åŒ–xterm.jsç»ˆç«¯
                this.term = new Terminal({
                    cursorBlink: true,
                    cursorStyle: 'block',
                    fontFamily: '"Courier New", monospace',
                    fontSize: 14,
                    theme: {
                        background: '#000000',
                        foreground: '#00ff00',
                        cursor: '#00ff00',
                        selection: '#ffffff',
                        black: '#000000',
                        red: '#ff0000',
                        green: '#00ff00',
                        yellow: '#ffff00',
                        blue: '#0000ff',
                        magenta: '#ff00ff',
                        cyan: '#00ffff',
                        white: '#ffffff'
                    }
                });

                // æ·»åŠ æ’ä»¶
                this.fitAddon = new FitAddon.FitAddon();
                this.term.loadAddon(this.fitAddon);

                // ç»‘å®šåˆ°DOM
                this.term.open(document.getElementById('terminal'));
                this.fitAddon.fit();

                // æ¬¢è¿ä¿¡æ¯
                this.term.writeln('\x1b[32mğŸ”¥ è€ç‹çš„Web Terminalå¯åŠ¨æˆåŠŸï¼\x1b[0m');
                this.term.writeln('\x1b[32mğŸ“± æ­£åœ¨è¿æ¥åˆ°å®¹å™¨ç»ˆç«¯...\x1b[0m');
                this.term.writeln('');
            }

            connect() {
                if (this.isConnecting) return;

                this.isConnecting = true;
                this.updateStatus('connecting');

                try {
                    // WebSocketè¿æ¥åˆ°åç«¯
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws/terminal`;

                    this.socket = new WebSocket(wsUrl);

                    this.socket.onopen = () => {
                        console.log('Terminal WebSocket connected');
                        this.isConnecting = false;
                        this.reconnectAttempts = 0;
                        this.updateStatus('connected');
                        this.term.writeln('\x1b[32mâœ… è¿æ¥æˆåŠŸï¼å¯ä»¥å¼€å§‹è¾“å…¥å‘½ä»¤äº†\x1b[0m');
                        this.term.writeln('');
                    };

                    this.socket.onmessage = (event) => {
                        // æ¥æ”¶åˆ°æœåŠ¡å™¨è¾“å‡º
                        this.term.write(event.data);
                    };

                    this.socket.onclose = () => {
                        console.log('Terminal WebSocket disconnected');
                        this.isConnecting = false;
                        this.updateStatus('disconnected');
                        this.term.writeln('\x1b[31mâŒ è¿æ¥æ–­å¼€\x1b[0m');

                        // è‡ªåŠ¨é‡è¿
                        if (this.reconnectAttempts < this.maxReconnectAttempts) {
                            this.reconnectAttempts++;
                            const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 10000);
                            this.term.writeln(`\x1b[33mğŸ”„ ${delay/1000}ç§’åé‡è¿ (${this.reconnectAttempts}/${this.maxReconnectAttempts})\x1b[0m`);
                            setTimeout(() => this.connect(), delay);
                        } else {
                            this.term.writeln('\x1b[31mâŒ é‡è¿å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢\x1b[0m');
                        }
                    };

                    this.socket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.term.writeln('\x1b[31mâŒ è¿æ¥é”™è¯¯\x1b[0m');
                    };

                } catch (error) {
                    console.error('Connection error:', error);
                    this.isConnecting = false;
                    this.updateStatus('error');
                    this.term.writeln(`\x1b[31mâŒ è¿æ¥å¤±è´¥: ${error.message}\x1b[0m`);
                }
            }

            updateStatus(status) {
                const indicator = document.getElementById('statusIndicator');
                const statusText = document.getElementById('statusText');

                indicator.className = 'status-indicator';

                switch (status) {
                    case 'connected':
                        indicator.classList.add('status-connected');
                        statusText.textContent = 'å·²è¿æ¥';
                        break;
                    case 'connecting':
                        indicator.style.background = '#ffff00';
                        statusText.textContent = 'è¿æ¥ä¸­...';
                        break;
                    case 'disconnected':
                        indicator.classList.add('status-disconnected');
                        statusText.textContent = 'å·²æ–­å¼€';
                        break;
                    case 'error':
                        indicator.style.background = '#ff0000';
                        statusText.textContent = 'è¿æ¥é”™è¯¯';
                        break;
                }
            }

            bindEvents() {
                // ç»ˆç«¯è¾“å…¥å¤„ç†
                this.term.onData((data) => {
                    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                        this.socket.send(data);
                    }
                });

                // çª—å£å¤§å°è°ƒæ•´
                window.addEventListener('resize', () => {
                    if (this.fitAddon) {
                        this.fitAddon.fit();
                        // é€šçŸ¥æœåŠ¡å™¨ç»ˆç«¯å¤§å°å˜åŒ–
                        if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                            const { cols, rows } = this.term;
                            this.socket.send(JSON.stringify({ resize: { cols, rows } }));
                        }
                    }
                });

                // æ§åˆ¶æŒ‰é’®
                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.term.clear();
                });

                document.getElementById('resizeBtn').addEventListener('click', () => {
                    this.fitAddon.fit();
                    this.term.writeln('\x1b[32mğŸ“ ç»ˆç«¯å¤§å°å·²è°ƒæ•´\x1b[0m');
                });

                document.getElementById('copyBtn').addEventListener('click', () => {
                    const selection = this.term.getSelection();
                    if (selection) {
                        navigator.clipboard.writeText(selection).then(() => {
                            this.term.writeln('\x1b[32mğŸ“‹ å·²å¤åˆ¶åˆ°å‰ªè´´æ¿\x1b[0m');
                        });
                    }
                });

                document.getElementById('pasteBtn').addEventListener('click', async () => {
                    try {
                        const text = await navigator.clipboard.readText();
                        this.term.write(text);
                        if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                            this.socket.send(text);
                        }
                    } catch (error) {
                        console.error('Paste failed:', error);
                    }
                });

                // é¡µé¢å…³é—­æ—¶æ–­å¼€è¿æ¥
                window.addEventListener('beforeunload', () => {
                    if (this.socket) {
                        this.socket.close();
                    }
                });
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–ç»ˆç«¯
        document.addEventListener('DOMContentLoaded', () => {
            const terminal = new WebTerminal();
        });
    </script>
</body>
</html>